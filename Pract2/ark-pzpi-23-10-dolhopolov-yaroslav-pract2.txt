﻿МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»





ЗВІТ
з практичної роботи
з дисципліни «Аналіз та рефакторінг коду»
на тему «Застосування методів “Replace Temp with Query”, “Replace Nested Conditional with Guard Clauses” та “Preserve Whole Object” для поліпшення коду на Visual Basic»




Виконав:
ст. гр. ПЗПІ-23-10
Долгополов Я. С.

Перевірив:
старший викл. Кафедри ПІ
Сокорчук І.П.


Харків 2025
     1) ЗАФІКСОВАНІ ЗМІНИ:
№ДатаВерсія звітуОпис змін та виправлень121.12.20250.1Створення титульної сторінки та написання мети роботи222.12.20250.2Вивчення та підбір методів рефакторингу Replace Temp with Query, Replace Nested Conditional with Guard Clauses, Preserve Whole Object323.12.20250.3Написання основного змісту, формулювання висновків, оформлення додатків     


     2) ЗАВДАННЯ.
     Мета роботи – мета роботи полягає у практичному дослідженні та застосуванні трьох методів рефакторингу з книги Мартіна Фаулера: Replace Temp with Query (81), Replace Nested Conditional with Guard Clauses (164) та Preserve Whole Object (188). На прикладах коду мовою Visual Basic демонструється процес ідентифікації “запахів коду” (тимчасові змінні, що ускладнюють читання; глибоко вкладені умови; довгі списки параметрів) та їхнє ефективне усунення для покращення читабельності, спрощення підтримки та підвищення якості дизайну програмного забезпечення.


     3) Хід роботи.
     1. ВСТУП.
     Сьогодні я продемонструю три методи рефакторингу, які допомагають боротися з різними, але дуже поширеними проблемами в коді. Ми розглянемо, як можна покращити читабельність, спростити логіку та поліпшити дизайн методів на прикладах мовою Visual Basic. Усе це спрямовано на створення чистішого та легшого у підтримці програмного забезпечення.
     2. Обрані методи.
     Ми розберемо три методи. Перший – “Replace Temp with Query” (Замінити тимчасову змінну запитом). Він бореться із зайвими проміжними змінними, які захаращують код. Другий – “Replace Nested Conditional with Guard Clauses” (Замінити вкладені умови захисними клаузами). Він покликаний розплутати “піраміду смерті” з вкладених If. І третій – “Preserve Whole Object” (Зберегти цілий об'єкт). Він допомагає позбутися довгих списків параметрів, що роблять методи громіздкими. Давайте детально розглянемо кожен з них.
     3. Суть методу: Replace Temp with Query.
     Перший метод, який ми розглянемо – “Replace Temp with Query”. Проблема, яку він вирішує – це надмірне використання тимчасових змінних.
     Подивимось на код до рефакторингу на цьому слайді. У функції CalculateTotal ми бачимо тимчасову змінну basePrice. Вона зберігає проміжний результат – добуток ціни на кількість. Потім ця змінна використовується двічі: в умові If і в поверненні результату. Це класичний “запах коду”: змінна не лише робить метод довшим, але й приховує просту логіку обчислення базової ціни, ускладнюючи повторне використання цієї логіки в інших місцях.
     4. Приклад рішення: Replace Temp with Query.
     Рішення просте та елегантне. Ми застосовуємо метод “Replace Temp with Query”. Це означає, що ми створюємо новий, окремий метод під назвою BasePrice, який інкапсулює формулу розрахунку. Потім ми просто замінюємо всі випадки використання старої змінної basePrice на виклик цього нового методу BasePrice(price, quantity).
     Переваги цього методу очевидні: ми позбулися зайвої змінної. Логіка обчислення тепер виділена в окремий, названий блок, який можна легко зрозуміти, протестувати та повторно використати. Сам метод CalculateTotal став більш декларативним – ми читаємо його як “якщо базова ціна більше 1000, повернути одну величину, інакше – іншу”.
     5. Суть методу: Replace Nested Conditional with Guard Clauses.
     Наступний метод – “Replace Nested Conditional with Guard Clauses”. Це, мабуть, один з найефективніших способів боротьби з поганою читабельністю.
     Проблема тут у так званій “піраміді смерті” – це глибоко вкладені умовні конструкції If. Подивимось на код до рефакторингу. Функція GetDiscountPercentage має три рівні вкладеності. Спочатку ми перевіряємо, чи об'єкт customer не є Nothing. Всередині – чи активний користувач. І всередині ще раз – чи його загальні покупки перевищують поріг. Щоб зрозуміти основний сценарій розрахунку знижки, нам потрібно пройти через всі ці шари. Це дуже ускладнює читання та підтримку такого коду.
     6. Приклад рішення: Replace Nested Conditional with Guard Clauses.
     Рішенням є застосування “захисних клауз”. Ідея проста: ми беремо всі перевірки на некоректні, помилкові або граничні стани і виносимо їх на самий початок методу. Якщо така умова виконується, метод негайно повертає результат або генерує виняток.
     Як видно у коді після рефакторингу, тепер на початку методу йдуть дві чіткі перевірки: на null та на активність користувача. Якщо хоча б одна з них не проходить, метод одразу завершується. Після цих “захисників” залишається чистий, лінійний та зрозумілий основний шлях логіки: перевірка суми покупок та розрахунок знижки. Перевага в тому, що код став плоским, його наміри – очевидними, а додавання нових умов тепер не призведе до створення нових рівнів вкладеності.
     7. Суть методу: Preserve Whole Object.
     І останній, третій метод – “Preserve Whole Object”. Проблема, з якою він бореться, знайома кожному, хто писав методи з довгими списками параметрів.
     Подивимось на код. Метод UpdateCustomerProfile приймає цілий набір окремих параметрів: street, city, postalCode. Але якщо придивитися, всі вони логічно належать до одного поняття – адреси. Це створює кілька проблем: метод має довгу та незграбну сигнатуру; при зміні структури адреси (наприклад, додаванні поля country) доведеться міняти сигнатуру цього та, можливо, багатьох інших методів; такий виклик важко читати, адже неочевидно, які параметри взаємопов'язані.
     8. Приклад рішення: Preserve Whole Object.
     Рішенням є об'єднання пов'язаних даних. Ми створюємо новий клас CustomerAddress, який групує всі поля адреси як свої властивості. Після цього ми замінюємо довгий список окремих параметрів в методі UpdateCustomerProfile на один параметр – об'єкт address типу CustomerAddress.
     Як видно у коді після рефакторингу, сигнатура методу стала значно коротшою та виразнішою. Тепер він приймає лише customerId, address та phone. Вся логіка роботи з адресою зосереджена всередині об'єкта. Це і є суть методу – зберегти та передати цілісний об'єкт, а не розбирати його на частини. Перевага в тому, що такий код набагато легше підтримувати: зміни в структурі адреси тепер відбуваються лише в одному класі, а інтерфейси методів залишаються стабільними та зрозумілими.
     

     4) ВИСНОВКИ.
     Підсумовуючи нашу роботу, ми на практиці побачили, як три різні методи рефакторингу дозволяють системно покращувати код, вирішуючи конкретні проблеми.
     Ми почали з методу “Replace Temp with Query”. Він допоміг нам позбутися зайвих тимчасових змінних, які лише захаращували логіку. Виділення обчислення в окремий метод не лише покращило читабельність, але й створило окремий блок, придатний для повторного використання та тестування. Це основа для написання більш декларативного та зрозумілого коду.
     Далі ми застосували “Replace Nested Conditional with Guard Clauses” для боротьби з найпоширенішим “запахом” – “пірамідою смерті”. Перетворення глибоко вкладених умов на серію ранніх перевірок дозволило нам розплутати складну логіку. В результаті основний шлях виконання став абсолютно прямим і очевидним, що значно полегшує аналіз коду та додавання нових умов без збільшення складності.
     Нарешті, метод “Preserve Whole Object” продемонстрував важливість гарного дизайну інтерфейсів. Заміна набору розрізнених параметрів на цілісний об'єкт не просто скоротила список аргументів – вона явно вказала на логічний зв'язок між даними та зміцнила зв'язність коду. Це робить систему стійкішою до змін: тепер додавання нового поля до адреси не вимагатиме змін у сигнатурах десятків методів.
     Таким чином, ці три методи разом охоплюють ключові аспекти чистого коду: елімінацію зайвих деталей (змінних), спрощення потоку управління та покращення структури даних. Кожен крок рефакторингу робить код не тільки чистішим, але й значно легшим для тестування, супроводу та майбутнього розширення, що є основним завданням сучасного програмного інженера.


     5) СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ.
     1. Fowler, M. Refactoring: Improving the Design of Existing Code. 2nd Edition. Addison-Wesley Professional, 2018. – 448 p. (Дата звернення 22.12.2025).
     2. Martin, R. C. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с. (Дата звернення 22.12.2025).
     3. Refactoring Guru: Каталог методів рефакторингу [Електронний ресурс]. – Режим доступу: https://refactoring.guru/uk/refactoring/catalog (Дата звернення 22.12.2025).
     4. Microsoft. Керівництво з програмного забезпечення Visual Basic [Електронний ресурс]. – Режим доступу: https://docs.microsoft.com/uk-ua/dotnet/visual-basic/ (Дата звернення 22.12.2025).


     ДОДАТОК А.
     Відеозапис.
     Відеозапис доповіді: 
     00:00 Титульний слайд.
     00:00 Обрані методи.
     00:00 Суть методу: Replace Temp with Query.
     00:00 Приклад рішення: Replace Temp with Query.
     00:00 Суть методу: Replace Nested Conditional with Guard Clauses.
     00:00 Приклад рішення: Replace Nested Conditional with Guard Clauses.
     00:00 Суть методу: Preserve Whole Object.
     00:00 Приклад рішення: Preserve Whole Object.
     00:00 Висновки
     

     ДОДАТОК Б.
     Слайди презентації:

     Рисунок Б.1 – Титульний слайд.

     Рисунок Б.2 – Обрані методи.

     Рисунок Б.3 – Суть методу: Replace Temp with Query.

     Рисунок Б.4 – Приклад рішення: Replace Temp with Query.

     Рисунок Б.5 – Суть методу: Replace Nested Conditional with Guard Clauses.

     Рисунок Б.6 – Приклад рішення: Replace Nested Conditional with Guard Clauses.

     Рисунок Б.7 – Суть методу: Preserve Whole Object.

     Рисунок Б.8 – Приклад рішення: Preserve Whole Object.

     Рисунок Б.9 – Висновки.
     

     ДОДАТОК В.
     Програмний код:
     Github репозиторій: https://github.com/NureDolhopolovYaroslav/ark-pzpi-23-10-dolhopolov-yaroslav/blob/main/Pract2/ark-pzpi-23-10-dolhopolov-yaroslav-pract2/code_examples.vb 
     В.1 Приклад для методу Replace Temp with Query:
       ' Код до рефакторингу
       Public Class OrderCalculator
           ' Проблема: тимчасова змінна basePrice захаращує логіку
           Public Function CalculateTotalOld(price As Decimal, quantity As Integer) As Decimal
               Dim basePrice As Decimal = price * quantity ' Зайва тимчасова змінна
               If basePrice > 1000 Then
                   Return basePrice * 0.95
               Else
                   Return basePrice * 0.98
               End If
           End Function
       End Class
       
       'Код після рефакторингу
       Public Class OrderCalculatorRefactored
           ' Рішення: логіка обчислення винесена в окремий метод-запит
           Public Function CalculateTotalNew(price As Decimal, quantity As Integer) As Decimal
               If BasePrice(price, quantity) > 1000 Then
                   Return BasePrice(price, quantity) * 0.95
               Else
                   Return BasePrice(price, quantity) * 0.98
               End If
           End Function
       
           ' Новий метод-запит, що інкапсулює логіку розрахунку
           Private Function BasePrice(price As Decimal, quantity As Integer) As Decimal
               Return price * quantity
           End Function
       End Class
     В.2 Приклад для методу Replace Nested Conditional with Guard Clauses:
       ' Код до рефакторингу
       Public Class DiscountService
           ' Проблема: "піраміда смерті" - глибоко вкладені умови
           Public Function GetDiscountPercentageOld(customer As Customer) As Decimal
               If customer IsNot Nothing Then
                   If customer.IsActive Then
                       If customer.TotalPurchases > 10000 Then
                           Return 0.1 ' 10%
                       Else
                           Return 0.05 ' 5%
                       End If
                   Else
                       Return 0 ' Неактивний клієнт
                   End If
               Else
                   Throw New ArgumentNullException(NameOf(customer))
               End If
           End Function
       End Class
       
       Public Class Customer
           Public Property IsActive As Boolean
           Public Property TotalPurchases As Decimal
       End Class
       
       ' Код після рефакторингу 
       Public Class DiscountServiceRefactored
           ' Рішення: захисні клаузи на початку роблять логіку лінійною
           Public Function GetDiscountPercentageNew(customer As Customer) As Decimal
               ' Захисна клауза 1: перевірка на null
               If customer Is Nothing Then
                   Throw New ArgumentNullException(NameOf(customer))
               End If
       
               ' Захисна клауза 2: перевірка на активність
               If Not customer.IsActive Then
                   Return 0
               End If
       
               ' Основний шлях виконання - тепер він чистий і зрозумілий
               If customer.TotalPurchases > 10000 Then
                   Return 0.1
               End If
       
               Return 0.05
           End Function
       End Class
     В.3 Приклад для методу Preserve Whole Object:
       ' Код до рефакторингу
       Public Class CustomerService
           ' Проблема: довгий список параметрів, що належать одній сутності
           Public Sub UpdateCustomerProfileOld(customerId As Integer,
                                               street As String,
                                               city As String,
                                               postalCode As String,
                                               phone As String)
               ' Логіка оновлення профілю
               Console.WriteLine($"Оновлення адреси: {street}, {city}, {postalCode}")
           End Sub
       End Class
       
       ' Код після рефакторингу
       
       ' Створюємо клас для групування пов'язаних даних
       Public Class CustomerAddress
           Public Property Street As String
           Public Property City As String
           Public Property PostalCode As String
       
           ' Можна додати корисні методи
           Public Overrides Function ToString() As String
               Return $"{Street}, {City}, {PostalCode}"
           End Function
       End Class
       
       Public Class CustomerServiceRefactored
           ' Рішення: передаємо цілісний об'єкт замість набору параметрів
           Public Sub UpdateCustomerProfileNew(customerId As Integer,
                                               address As CustomerAddress,
                                               phone As String)
               ' Логіка стала набагато чистішою
               Console.WriteLine($"Оновлення адреси: {address.ToString()}")
           End Sub
       
           ' Приклад виклику методу
           Public Sub DemoMethodCall()
               ' Створення об'єкта адреси
               Dim customerAddress As New CustomerAddress() With {
                   .Street = "вул. Наукова, 42",
                   .City = "Харків",
                   .PostalCode = "61152"
               }
       
               ' Виклик методу з одним об'єктом замість трьох параметрів
               UpdateCustomerProfileNew(123, customerAddress, "+380999999999")
           End Sub
       End Class
2


